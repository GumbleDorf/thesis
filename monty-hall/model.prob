%The following problog program models the monty hall problem in a way that incorporates some GDL-III concepts
role(candidate). role(random).

%The following 4 predicates are public knowledge
step(1). door(1). door(2). door(3).

%----------------------------------------------------------------

%Legality and effects of choose_door
legal(choose_door(candidate, door(X), step(1))) :- 
    door(X), 
    step(1).

door_chosen(candidate, door(X), step(Z)) :-
    choose_door(candidate, door(X), step(Y)),
    plus(Y,1,Z).

%----------------------------------------------------------------

%Legality and effects of place_car
legal(place_car(random, door(X), step(1))) :- 
    door(X), 
    step(1).

%The candidate does not know where the car was placed
car(door(X), step(Z)) :- place_car(random, door(X), step(Y)), plus(Y,1,Z).
%Position of car is never changed
car(door(X),step(Z)) :- car(door(X),step(Y)), plus(Y,1,Z).

%Candidate thinks of every possible car placement
1/P::knows(candidate,car(door(X),step(2))) :- 
    findall(Y,legal(place_car(random, door(Y),step(1))),Doors),
    length(Doors,P), P > 0.

%----------------------------------------------------------------
%Legality of the noop on step 2, no knowledge gained from this action
legal(noop(candidate, step(2))) :- step(2).
%----------------------------------------------------------------
%Legality and effects of revealing a door
legal(reveal_door(random, door(X), step(2))) :- 
    door(X),
    not car(door(X), step(_)),
    not door_chosen(candidate, door(X), step(_)), 
    step(2).

knows(candidate,not car(door(X),step(Z))) :-
    reveal_door(random, door(X), step(Y)),
    plus(Y,1,Z).

%The legality of this move depends on information that the candidate does not have
%Therefore, we construct a knowledge base of what it believes to be legal
%THIS BIT IS AN ISSUE, I DON'T KNOW HOW I WOULD REPRESENT THIS IN GDL-III OR DERIVE A TRANSLATION FROM A SPEC
1/P::knows(candidate,given(legal(reveal_door(random, door(X), step(2)))),door_chosen(Y), car(Z)) :-
    possible(knows(candidate,car(door(Z),step(2)))),
    door_chosen(candidate,door(Y), step(_)),
    notSameDoor(X,Y,Z),
    findall(A, notSameDoor(A,Y,Z), PossibleDoors),
    length(PossibleDoors, P),
    P > 0.

notSameDoor(X,Y,Z) :-
    door(X),
    door(Y),
    door(Z),
    X \= Y,
    X \= Z.

% This ends up with a non-normalised result of 1/6 don't switch, 1/3 switch, should use different approach
knows(candidate,car(door(Z),step(3))) :-
    knows(candidate,not car(door(X),step(3))),
    knows(candidate,car(door(Z),step(2))),
    knows(candidate,given(legal(reveal_door(random, door(X), step(2)))),door_chosen(_), car(Z)).



%----------------------------------------------------------------
%Noop for random player in step 3
legal(noop(random, step(3))) :- step(3).
%----------------------------------------------------------------
%Legality and effects of player choosing to switch in step 3
legal(switch_door(candidate, door(X), step(3))) :- 
    door(X),
    not door_chosen(candidate,door(X), step(_)),
    not reveal_door(random, door(X), step(_)), 
    step(3).


%evaluation on whether we choose to switch to a door or not
choose(candidate,door(X),step(4)) :- 
    switch_door(candidate, door(X), step(3)),
    legal(switch_door(candidate, door(X), step(3))).



%Establish number of steps
step(Y) :- step(X), not terminal(X),plus(X,1,Y).
%Game ends at step 4
terminal(4).

goal(candidate,100) :- choose(candidate,door(X),step(Y)), car(door(X), step(_)), terminal(Y).
goal(candidate,0) :- not goal(candidate, 100).

%choose_door(candidate, door(1), step(1)).
%place_car(random, door(2), step(1)).
%reveal_door(random, door(3), step(2)).
%switch_door(candidate, door(X), step(3)).
%query(goal(candidate,100)).
